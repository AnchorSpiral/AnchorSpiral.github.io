<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>3D Resonant Brain Refined</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; color: #0f0; font-family: Arial, sans-serif; }
  #ui {
    position: fixed; top: 10px; left: 10px; padding: 12px;
    background: rgba(0,0,0,0.7); border-radius: 8px; width: 280px;
    font-size: 14px; border: 1px solid #0f0; z-index: 20;
  }
  .slider { width: 100%; accent-color: #0f0; }
  button {
    background: #0f0; border: none; padding: 6px 10px; margin-top: 6px;
    border-radius: 4px; cursor: pointer;
  }
  button:hover { background: #0a0; }
  canvas { display: block; position: fixed; top: 0; left: 0; }
</style>
</head>
<body>

<div id="ui">
  <div><b>Global Coherence (R):</b> <span id="R">0.00</span></div>
  <div><b>Entropy (nats):</b> <span id="H">0.00</span></div>
  <div><b>Work (×10⁻²¹ J):</b> <span id="W">0.00</span></div>
  <hr style="border-color:#0f0; margin: 8px 0;">
  <label>η: <input type="range" id="eta" min="0" max="0.3" step="0.001" value="0.08" class="slider"></label><br>
  <label>γ: <input type="range" id="gamma" min="0" max="0.2" step="0.001" value="0.06" class="slider"></label><br>
  <label>Noise: <input type="range" id="noise" min="0" max="0.01" step="0.0001" value="0.003" class="slider"></label><br>
  <button onclick="reset()">Reset Simulation</button>
  <button onclick="paused = !paused">Pause / Resume</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x000000);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  camera.position.set(0, 0, 6); // Move camera back a bit more

  // Add a bright test cube at origin to check visibility
  const testCubeGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
  const testCubeMat = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
  const testCube = new THREE.Mesh(testCubeGeo, testCubeMat);
  scene.add(testCube);

  camera.lookAt(scene.position);

  const N = 50;
  const D = 32;
  let agents = [], spheres = [];
  let paused = false;
  let t = 0;

  const ui = { eta: 0.08, gamma: 0.06, noise: 0.003 };
  document.getElementById('eta').oninput = e => ui.eta = +e.target.value;
  document.getElementById('gamma').oninput = e => ui.gamma = +e.target.value;
  document.getElementById('noise').oninput = e => ui.noise = Math.sqrt(+e.target.value);

  function norm(v) {
    const m = Math.sqrt(v.reduce((s,x)=>s+x*x,0)) || 1;
    return v.map(x => x/m);
  }

  function dot(a,b) { return a.reduce((s,x,i)=> s + x*b[i], 0); }

  function hsvToRgb(h, s, v) {
    const i = Math.floor(h * 6), f = h * 6 - i;
    const p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0: return [v,p,t];
      case 1: return [q,v,p];
      case 2: return [p,v,t];
      case 3: return [p,q,v];
      case 4: return [t,p,v];
      case 5: return [v,p,q];
    }
  }

  function reset() {
    while(scene.children.length > 1) scene.remove(scene.children[1]);
    agents = [];
    spheres = [];
    for(let i = 0; i < N; i++) {
      const v = new Array(D).fill(0).map(() => (Math.random() - 0.5) * 2);
      agents.push({ S: norm(v) });

      // Position spheres in 3D space on radius 2
      const theta = Math.acos(2 * Math.random() - 1);
      const phi = 2 * Math.PI * Math.random();
      const r = 2.0;
      const x = r * Math.sin(theta) * Math.cos(phi);
      const y = r * Math.sin(theta) * Math.sin(phi);
      const z = r * Math.cos(theta);

      const geom = new THREE.SphereGeometry(0.25, 12, 12);
      const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      const sphere = new THREE.Mesh(geom, mat);
      sphere.position.set(x, y, z);
      scene.add(sphere);
      spheres.push(sphere);

      agents[i].pos = { x, y, z };
    }
    t = 0;
    updateColors();
  }

  function updateColors() {
    agents.forEach((a, i) => {
      const proj = [
        dot(a.S, new Array(D).fill(0).map((_, j) => j === 0 ? 1 : 0)),
        dot(a.S, new Array(D).fill(0).map((_, j) => j === 1 ? 1 : 0)),
        dot(a.S, new Array(D).fill(0).map((_, j) => j === 2 ? 1 : 0))
      ];
      const [r, g, b] = hsvToRgb((proj[0] + 1) / 2, (proj[1] + 1) / 2, (proj[2] + 1) / 2 * 0.8 + 0.2);
      spheres[i].material.color.setRGB(r, g, b);
    });
  }

  function update() {
    if (paused) return;
    const updates = agents.map(a => {
      const avg = new Array(D).fill(0);
      agents.forEach(b => { if (b !== a) b.S.forEach((x, i) => avg[i] += x); });
      avg.forEach((_, i) => avg[i] /= (N - 1));
      const diff = avg.map((x, i) => x - a.S[i]);
      const noise = new Array(D).fill(0).map(() => (Math.random() - 0.5) * ui.noise);
      const gradU = a.S.slice();
      const newS = a.S.map((s, i) => s + ui.eta * 0.8 * diff[i] - ui.gamma * gradU[i] + noise[i]);
      return norm(newS);
    });
    agents.forEach((a, i) => a.S = updates[i]);

    scene.children = scene.children.filter(child => !(child instanceof THREE.Line));

    let totalR = 0, totalH = 0, pairs = 0;
    for (let i = 0; i < N; i++)
      for (let j = i + 1; j < N; j++) {
        const cos = dot(agents[i].S, agents[j].S);
        if (cos > 0.4) {
          totalR += cos; pairs++;
          const geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(agents[i].pos.x, agents[i].pos.y, agents[i].pos.z),
            new THREE.Vector3(agents[j].pos.x, agents[j].pos.y, agents[j].pos.z)
          ]);
          const material = new THREE.LineBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: (cos - 0.4) / 0.6 * 0.6
          });
          const line = new THREE.Line(geometry, material);
          scene.add(line);
        }
      }
    const R = pairs > 0 ? totalR / pairs : 0;
    agents.forEach(a => {
      totalH -= a.S.reduce((s, x) => s + x * Math.log(x + 1e-15), 0);
    });
    const H = totalH / N;
    const initialH = 3.465;
    const W = Math.max(0, (initialH - H) / Math.log(2) * 2.87e-21);

    document.getElementById('R').textContent = R.toFixed(3);
    document.getElementById('H').textContent = H.toFixed(3);
    document.getElementById('W').textContent = (W * 1e21).toFixed(2);

    updateColors();
    t++;
  }

  function animate() {
    requestAnimationFrame(animate);
    update();
    controls.update();
    renderer.render(scene, camera);
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  reset();
  animate();
</script>

</body>
</html>